#include "stdafx.h"
// Using =======================================================================
namespace py = pybind11;

// Module ======================================================================
void Export_pystes_UActionSequence(py::module &m)
{
    py::class_< UActionSequence,  UObject   >(m, "UActionSequence")
        .def_readwrite("ResourcesUsed", &UActionSequence::ResourcesUsed)
        .def_readwrite("MyRuleEngine", &UActionSequence::MyRuleEngine)
        .def_readwrite("AttachedRule", &UActionSequence::AttachedRule)
        .def_readwrite("LatentFloat", &UActionSequence::LatentFloat)
        .def_readwrite("ParentSequence", &UActionSequence::ParentSequence)
        .def_readwrite("ChildSequence", &UActionSequence::ChildSequence)
        .def_readwrite("TheAIFactory", &UActionSequence::TheAIFactory)
        .def_readwrite("ContextMenu", &UActionSequence::ContextMenu)
        .def_readwrite("StoredDeltaTime", &UActionSequence::StoredDeltaTime)
        .def_readwrite("FlagValuesToSetOnBegin", &UActionSequence::FlagValuesToSetOnBegin)
        .def_readwrite("FlagValuesToSetOnEnd", &UActionSequence::FlagValuesToSetOnEnd)
        .def_readwrite("AI", &UActionSequence::AI)
        .def_readwrite("BehaviorOutputs", &UActionSequence::BehaviorOutputs)
        .def_readwrite("BehaviorName", &UActionSequence::BehaviorName)
        .def("StaticClass", &UActionSequence::StaticClass, py::return_value_policy::reference)
        .def("TriggerBehavior", &UActionSequence::TriggerBehavior)
        .def("GetRangeValue", &UActionSequence::GetRangeValue)
        .def("RangeIsValid", &UActionSequence::RangeIsValid)
        .def("Finish", &UActionSequence::Finish)
        .def("IsRunning", &UActionSequence::IsRunning)
        .def("eventScriptCleanUp", &UActionSequence::eventScriptCleanUp)
        .def("eventCanRun", &UActionSequence::eventCanRun)
        .def("eventActivateEvent", &UActionSequence::eventActivateEvent)
        .def("eventUpdate", &UActionSequence::eventUpdate)
        .def("eventInit", &UActionSequence::eventInit)
        .def("eventStop", &UActionSequence::eventStop)
        .def("eventStart", &UActionSequence::eventStart)
        .def("eventInterruptSequence", &UActionSequence::eventInterruptSequence)
        .def("eventStopSequence", &UActionSequence::eventStopSequence)
        .def("eventStartSequence", &UActionSequence::eventStartSequence)
        .def("ExecuteSequence", &UActionSequence::ExecuteSequence)
        .def("Sleep", &UActionSequence::Sleep)
        .def("RunSubSequence", &UActionSequence::RunSubSequence)
        .def("InterruptLatentAction", &UActionSequence::InterruptLatentAction)
        .def("DoRuleSetPop", &UActionSequence::DoRuleSetPop)
        .def("DoRuleSetPush", &UActionSequence::DoRuleSetPush)
        .def("DoRuleSetSwitch", &UActionSequence::DoRuleSetSwitch)
        .def("PreventNewRulesFromStarting", &UActionSequence::PreventNewRulesFromStarting)
        .def("GetRuleNative", &UActionSequence::GetRuleNative, py::return_value_policy::reference)
        .def("GetActionSequence", [](UActionSequence &self , class UActionSequence* Template) { class UActionSequence** pyOutSequence = 0 ;   self.GetActionSequence(Template, pyOutSequence); return py::make_tuple(*pyOutSequence); })
        .def("IsInLabel", &UActionSequence::IsInLabel)
        .def("IsAtomic", &UActionSequence::IsAtomic)
        .def("StopAtomic", &UActionSequence::StopAtomic)
        .def("StartAtomic", &UActionSequence::StartAtomic)
        .def("IsActionReadyToFinish", &UActionSequence::IsActionReadyToFinish)
          ;
}